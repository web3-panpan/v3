"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerCompiler = exports.BinaryCompiler = exports.compile = void 0;
const binary_1 = require("./binary");
const semver_1 = __importDefault(require("semver"));
const docker_1 = require("./docker");
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
async function compile(zksolcConfig, input, solcPath) {
    let compiler;
    if (zksolcConfig.compilerSource == 'binary') {
        if (solcPath == null) {
            throw new errors_1.ZkSyncSolcPluginError('solc executable is not specified');
        }
        compiler = new BinaryCompiler(solcPath);
    }
    else if (zksolcConfig.compilerSource == 'docker') {
        compiler = await DockerCompiler.initialize(zksolcConfig);
    }
    else {
        throw new errors_1.ZkSyncSolcPluginError(`Incorrect compiler source: ${zksolcConfig.compilerSource}`);
    }
    return await compiler.compile(input, zksolcConfig);
}
exports.compile = compile;
class BinaryCompiler {
    constructor(solcPath) {
        this.solcPath = solcPath;
    }
    async compile(input, config) {
        // Check for missing libraries
        if (semver_1.default.gte(config.version, constants_1.DETECT_MISSING_LIBRARY_MODE_COMPILER_VERSION)) {
            const zkSolcOutput = await (0, binary_1.compileWithBinary)(input, config, this.solcPath, true);
            const missingLibraries = (0, utils_1.findMissingLibraries)(zkSolcOutput);
            if (missingLibraries.size > 0) {
                if (!config.settings.missingLibrariesPath) {
                    throw new errors_1.ZkSyncSolcPluginError('Missing libraries path is not specified');
                }
                const missingLibraryDependencies = (0, utils_1.mapMissingLibraryDependencies)(zkSolcOutput, missingLibraries);
                // Write missing libraries to file
                const missingLibrariesPath = config.settings.missingLibrariesPath;
                await (0, utils_1.writeLibrariesToFile)(missingLibrariesPath, missingLibraryDependencies);
                config.settings.areLibrariesMissing = true;
                return zkSolcOutput;
            }
        }
        return await (0, binary_1.compileWithBinary)(input, config, this.solcPath);
    }
}
exports.BinaryCompiler = BinaryCompiler;
class DockerCompiler {
    constructor(dockerImage, docker) {
        this.dockerImage = dockerImage;
        this.docker = docker;
    }
    static async initialize(config) {
        var _a, _b;
        await (0, docker_1.validateDockerIsInstalled)();
        const image = (0, docker_1.dockerImage)((_a = config.settings.experimental) === null || _a === void 0 ? void 0 : _a.dockerImage, (_b = config.settings.experimental) === null || _b === void 0 ? void 0 : _b.tag);
        const docker = await (0, docker_1.createDocker)();
        await (0, docker_1.pullImageIfNecessary)(docker, image);
        return new DockerCompiler(image, docker);
    }
    async compile(input, config) {
        // We don't check here for missing libraries because docker is using older versions of zksolc and it's deprecated
        return await (0, docker_1.compileWithDocker)(input, this.docker, this.dockerImage, config);
    }
    async solcVersion() {
        const versionOutput = await (0, docker_1.getSolcVersion)(this.docker, this.dockerImage);
        const longVersion = versionOutput.match(/^Version: (.*)$/)[1];
        const version = longVersion.split('+')[0];
        return { version, longVersion };
    }
}
exports.DockerCompiler = DockerCompiler;
//# sourceMappingURL=index.js.map