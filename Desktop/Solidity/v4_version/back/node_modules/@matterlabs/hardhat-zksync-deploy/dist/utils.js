"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWallet = exports.compileContracts = exports.removeLibraryInfoFile = exports.getLibraryInfos = exports.fillLibrarySettings = exports.generateFullQuailfiedNameString = exports.updateHardhatConfigFile = exports.isHttpNetworkConfig = void 0;
const morph_ts_builder_1 = require("./morph-ts-builder");
const fs_1 = __importDefault(require("fs"));
const errors_1 = require("./errors");
const zksync_web3_1 = require("zksync-web3");
function isHttpNetworkConfig(networkConfig) {
    return 'url' in networkConfig;
}
exports.isHttpNetworkConfig = isHttpNetworkConfig;
function updateHardhatConfigFile(hre, externalConfigObjectPath, exportedConfigObject) {
    try {
        new morph_ts_builder_1.MorphTsBuilder(externalConfigObjectPath !== null && externalConfigObjectPath !== void 0 ? externalConfigObjectPath : hre.config.paths.configFile)
            .intialStep([{ initialVariableType: "HardhatUserConfig" }, { initialVariable: exportedConfigObject }, { initialModule: "module.exports" }])
            .nextStep({ propertyName: 'zksolc', isRequired: true })
            .nextStep({ propertyName: 'settings' })
            .replaceStep({ propertyName: 'libraries', replaceObject: hre.config.zksolc.settings.libraries })
            .save();
    }
    catch (error) {
        throw new errors_1.ZkSyncDeployPluginError('Failed to update hardhat config file, please use addresses from console output');
    }
}
exports.updateHardhatConfigFile = updateHardhatConfigFile;
function generateFullQuailfiedNameString(contractFQN) {
    return contractFQN.contractPath + ":" + contractFQN.contractName;
}
exports.generateFullQuailfiedNameString = generateFullQuailfiedNameString;
async function fillLibrarySettings(hre, libraries) {
    libraries.forEach((library) => {
        let contractPath = library.contractFQN.contractPath;
        let contractName = library.contractFQN.contractName;
        if (!hre.config.zksolc.settings.libraries) {
            hre.config.zksolc.settings.libraries = {};
        }
        hre.config.zksolc.settings.libraries[contractPath] = {
            [contractName]: library.address
        };
    });
}
exports.fillLibrarySettings = fillLibrarySettings;
function getLibraryInfos(hre) {
    const libraryPathFile = hre.config.zksolc.settings.missingLibrariesPath;
    if (!fs_1.default.existsSync(libraryPathFile)) {
        throw new errors_1.ZkSyncDeployPluginError('Missing librararies file not found');
    }
    return JSON.parse(fs_1.default.readFileSync(libraryPathFile, 'utf8'));
}
exports.getLibraryInfos = getLibraryInfos;
function removeLibraryInfoFile(hre) {
    const libraryPathFile = hre.config.zksolc.settings.missingLibrariesPath;
    if (fs_1.default.existsSync(libraryPathFile)) {
        fs_1.default.rmSync(libraryPathFile);
    }
}
exports.removeLibraryInfoFile = removeLibraryInfoFile;
async function compileContracts(hre, contracts) {
    hre.config.zksolc.settings.contractsToCompile = contracts;
    await hre.run('compile', { force: true });
}
exports.compileContracts = compileContracts;
function getWallet(hre, privateKey, accountNumber) {
    if (privateKey) {
        return new zksync_web3_1.Wallet(privateKey);
    }
    const accounts = hre.network.config.accounts;
    if (!accounts) {
        throw new errors_1.ZkSyncDeployPluginError('Accounts for selected newtwork are not specified');
    }
    if (isHardhatNetworkAccountsConfigStrings(accounts)) {
        const accountPrivateKey = accounts[accountNumber];
        if (!accountPrivateKey) {
            throw new errors_1.ZkSyncDeployPluginError('Account private key with specified index is not found');
        }
        return new zksync_web3_1.Wallet(accountPrivateKey);
    }
    if (isHardhatNetworkHDAccountsConfig(accounts)) {
        const account = accounts;
        return zksync_web3_1.Wallet.fromMnemonic(account.mnemonic, account.path);
    }
    const account = accounts[accountNumber];
    if (!account) {
        throw new errors_1.ZkSyncDeployPluginError('Account with specified index is not found');
    }
    return new zksync_web3_1.Wallet(account.privateKey);
}
exports.getWallet = getWallet;
function isHardhatNetworkHDAccountsConfig(object) {
    return 'mnemonic' in object;
}
function isHardhatNetworkAccountsConfigStrings(object) {
    return typeof object[0] === 'string';
}
//# sourceMappingURL=utils.js.map